# 全栈架构文档: 电力设备制造商CPQ系统

## 简介 (Introduction) [cite: 875]
本文档概述了 **电力设备制造商CPQ系统** 的完整全栈架构，包括后端系统、前端实现及其集成 [cite: 880, 881]。它将作为AI驱动开发过程的唯一技术真实来源，确保整个技术栈的一致性。

### 启动模板或现有项目 (Starter Template or Existing Project) [cite: 883]
* **决策**: 项目将从零开始手动构建，不使用任何现成的启动模板，以确保最大的定制灵活性。

### 变更日志 (Change Log) [cite: 888]
| 日期 | 版本 | 描述 | 作者 |
| :--- | :--- | :--- | :--- |
| 2025年7月30日 | 1.0 | 初始架构文档创建 | Winston (Architect) |

## 高阶架构 (High Level Architecture) [cite: 889]

### 技术摘要 (Technical Summary) [cite: 891]
本系统将采用一个务实的、单体服务的Monorepo架构。后端使用Python Flask框架，搭配SQLite数据库，对外提供REST API。前端将采用现代JavaScript框架（如Vue或React），构建一个响应式的单页应用(SPA)。整个应用在MVP阶段将部署在基础的云服务器上，架构设计会为未来向更复杂模式的演进以及AI和CRM等系统的集成预留扩展点。

### 平台与基础设施选择 (Platform and Infrastructure Choice) [cite: 892]
* **平台**: 考虑到MVP阶段的快速部署和成本效益，建议使用基础的云服务器平台（如AWS EC2, DigitalOcean Droplet, 或类似的IaaS服务）。
* **关键服务**: MVP阶段仅需一台Linux云服务器（用于运行Web服务器和Flask应用）和配套的对象存储服务（可选，用于存储生成的PDF等文件）。

### 代码仓库结构 (Repository Structure) [cite: 897]
* **结构**: Monorepo。前后端代码、共享工具和部署脚本都将存放在同一个Git仓库中。

### 高阶架构图 (High Level Architecture Diagram) [cite: 899]
```mermaid
graph TD
    User[用户 (销售/工程师)] --> Browser[浏览器]
    
    subgraph "云服务器"
        Browser -- HTTPS --> WebServer[Web 服务器 (如 Nginx)]
        WebServer -- 静态文件 --> SPA[前端单页应用]
        WebServer -- API请求 --> API[后端REST API (Flask)]
        API -- 读/写 --> DB[(SQLite数据库文件)]
    end

    style User fill:#D6EAF8
    style DB fill:#E8DAEF
架构模式 (Architectural Patterns) 

后端 - REST API: 后端将通过一个标准化的RESTful API与前端通信，使用JSON作为数据交换格式。


后端 - 仓库模式 (Repository Pattern): 我们将抽象数据库操作，将业务逻辑与数据访问代码分离 。这使得未来从SQLite迁移到其他数据库变得更加容易。

前端 - 基于组件的UI (Component-Based UI): 前端将使用可复用的组件来构建用户界面，提高开发效率和可维护性。

技术栈 (Tech Stack) 

这张表格是项目的唯一技术真实来源 (single source of truth) 。开发团队必须严格遵守这里列出的技术和版本。

分类	技术	版本	用途	理由
后端语言	Python	3.11.x	后端开发语言	成熟稳定，生态丰富，与Flask完美配合。
后端框架	Flask	3.0.x	Web服务框架	轻量、灵活，适合快速开发API。
数据库	SQLite	3.x	MVP阶段数据存储	无需单独的服务，集成在应用中，零配置，适合MVP。
API风格	REST	-	前后端通信标准	成熟、通用、易于理解和实现。
前端语言	TypeScript	5.4.x	前端开发语言	为JavaScript提供类型安全，提高代码质量和可维护性。
前端框架	Vue.js	3.4.x	构建用户界面	学习曲线平缓，性能出色，生态系统完善。
UI组件库	Element Plus	2.7.x	UI组件	专为Vue 3设计，提供丰富、高质量的企业级组件。
前端构建工具	Vite	5.2.x	开发服务器与打包	极速的冷启动和热更新，提供一流的开发体验。
后端测试	Pytest	8.2.x	单元/集成测试	功能强大，插件丰富，是Python测试的事实标准。
前端测试	Vitest	1.6.x	单元/组件测试	与Vite无缝集成，快速且API兼容Jest。
E2E测试	Playwright	1.44.x	端到端测试	微软出品，支持所有现代浏览器，稳定可靠。
代码格式化	Prettier	3.2.x	统一代码风格	自动化格式化代码，确保代码风格一致性。

导出到 Google 表格
数据模型 (Data Models) 

为了确保前后端数据一致性，我们会为每个模型定义一个共享的TypeScript接口。

模型: 角色 (Role)
目的: 定义用户的权限等级。

TypeScript 接口:

TypeScript

// located in: packages/shared/src/types/roles.ts
export interface Role { id: number; name: 'admin' | 'engineer' | 'sales'; }
模型: 用户 (User)
目的: 存储用户的登录凭证和基本信息，并关联一个角色。

TypeScript 接口:

TypeScript

// located in: packages/shared/src/types/users.ts
import { Role } from './roles';
export interface User { id: number; username: string; email: string; role: Role; }
模型: 产品 (Product)
目的: 存储电力设备的详细信息。

TypeScript 接口:

TypeScript

// located in: packages/shared/src/types/products.ts
export interface Product { id: number; name: string; sku: string; description: string; base_price: number; parameters: Record<string, any>; }
模型: 报价单 (Quote) & 报价项 (QuoteItem)
目的: 代表一份完整的报价单及其中的项目。

TypeScript 接口:

TypeScript

// located in: packages/shared/src/types/quotes.ts
import { User } from './users';
import { Product } from './products';
export interface QuoteItem { id: number; product: Product; quantity: number; unit_price: number; }
export interface Quote { id: number; customer_info: Record<string, any>; total_price: number; created_by: User; created_at: string; items: QuoteItem[]; }
API 规范 (API Specification) 

API是前端和后端之间的“合同”。所有端点（除登录外）都需要身份认证。

认证: POST /api/login, POST /api/logout

用户与角色: GET /api/users, PUT /api/users/{id}/role

产品: POST /api/products, GET /api/products, GET /api/products/{id}, PUT /api/products/{id}, DELETE /api/products/{id}

报价单: POST /api/quotes, GET /api/quotes, GET /api/quotes/{id}

组件 (Components) 

后端组件: 认证服务、用户与角色服务、产品目录服务、报价服务、PDF生成服务。

前端组件: 认证模块、产品目录模块、报价模块。

核心工作流程 (Core Workflows) 

工作流程: 创建报价单

代码段

sequenceDiagram
    participant User as 用户
    participant FE as 前端 (报价模块)
    participant API as 后端API (Flask)
    participant DB as 数据库 (SQLite)

    User->>FE: 1. 填写信息并点击“创建报价”
    activate FE
    FE->>API: 2. POST /api/quotes (携带报价单数据)
    activate API
    API->>DB: 3. 查询、计算并写入数据库
    activate DB
    DB-->>API: 4. 返回创建结果
    deactivate DB
    API-->>FE: 5. 返回201 Created
    deactivate API
    FE->>User: 6. 显示“创建成功”
    deactivate FE
数据库模式 (Database Schema) 

SQL

CREATE TABLE roles ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL UNIQUE );
CREATE TABLE users ( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT NOT NULL UNIQUE, email TEXT NOT NULL UNIQUE, password_hash TEXT NOT NULL, role_id INTEGER NOT NULL, FOREIGN KEY (role_id) REFERENCES roles (id) );
CREATE TABLE products ( id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT NOT NULL, sku TEXT NOT NULL UNIQUE, description TEXT, base_price REAL NOT NULL, parameters TEXT );
CREATE TABLE quotes ( id INTEGER PRIMARY KEY AUTOINCREMENT, customer_info TEXT, total_price REAL NOT NULL, created_by_user_id INTEGER NOT NULL, created_at TEXT NOT NULL, FOREIGN KEY (created_by_user_id) REFERENCES users (id) );
CREATE TABLE quote_items ( id INTEGER PRIMARY KEY AUTOINCREMENT, quote_id INTEGER NOT NULL, product_id INTEGER NOT NULL, quantity INTEGER NOT NULL, unit_price REAL NOT NULL, FOREIGN KEY (quote_id) REFERENCES quotes (id), FOREIGN KEY (product_id) REFERENCES products (id) );
前端架构 (Frontend Architecture) 


组件组织: 按功能组织 (shared/, products/, quotes/, auth/)。 


状态管理: 使用Pinia，按功能模块划分Store (auth.store.ts, products.store.ts)。 

路由: 使用Vue Router，实现路由懒加载和基于 meta: { requiresAuth: true } 的路由守卫。


服务层: 使用Axios，通过拦截器自动附加JWT令牌。 

后端架构 (Backend Architecture) 

目录结构: 采用分层结构 (models/, repositories/, services/, routes/)。


数据库: 使用SQLAlchemy作为ORM，通过Alembic进行数据库迁移。 


认证: 使用JWT，通过路由装饰器进行角色授权。 

统一项目结构 (Unified Project Structure) 

Plaintext

cpq-system/                  # Monorepo 根目录
├── apps/                      # 存放独立的应用
│   ├── api/                   # 后端 Flask 应用
│   └── web/                   # 前端 Vue 应用
├── packages/                  # 存放共享的代码包
│   └── shared/                # 前后端共享的代码
│       └── src/types/         # (我们定义的共享TypeScript接口)
├── scripts/                   # 项目脚本 (如: 数据库迁移, 部署)
├── docs/                      # 项目文档 (PRD, Architecture, etc.)
├── package.json               # Monorepo 根 package.json (用于管理工作区)
└── README.md
开发工作流程 (Development Workflow) 

本地设置: 开发者需要在根目录运行 npm install 来安装所有依赖。创建一个 .env 文件来存放环境变量。

开发命令: npm run dev 应能同时启动前后端开发服务器。

部署架构 (Deployment Architecture) 


部署策略: 通过CI/CD流水线（如GitHub Actions）自动化构建和部署 。前端部署为静态文件，后端部署为WSGI应用。


环境: 至少包含开发、预发和生产三个环境。 

安全与性能 (Security and Performance) 

安全: 所有用户输入都必须在后端进行验证。密码必须哈希存储。使用环境变量管理密钥，绝不硬编码。

性能: 前端应使用代码分割和懒加载。后端应对数据库查询进行优化，特别是针对产品表的搜索。

测试策略 (Testing Strategy) 


测试金字塔: 遵循完整的测试金字塔策略。 

前端: 使用Vitest进行单元/组件测试。

后端: 使用Pytest进行单元/集成测试。

端到端: 使用Playwright覆盖关键用户流程。

编码标准 (Coding Standards) 


类型共享: 前后端必须使用 packages/shared/src/types/ 中的共享TypeScript类型来定义数据结构。 


API调用: 前端必须通过服务层调用API，禁止在组件中直接发起HTTP请求。 

错误处理 (Error Handling) 


统一格式: 后端API应返回统一的JSON错误格式。 

处理: 后端使用全局错误处理器捕获异常。前端在服务层捕获API错误并更新UI状态。

监控 (Monitoring) 

日志: 前后端应用都应进行结构化日志记录。

健康检查: 后端API应提供一个 /health 端点用于健康检查。

检查清单结果报告 (Checklist Results Report) 

概要: 本架构文档全面、务实，且与PRD和UI/UX规格文档保持一致。所有技术决策均有明确理由，并为未来扩展提供了路径。

最终决定: READY FOR DEVELOPMENT (已准备好进入开发阶段)。